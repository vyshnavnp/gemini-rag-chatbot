name: Deploy OncoBot to AWS ECR

on:
  push:
    branches: ["main", "master"] # Added "master" branch trigger for safety

jobs:
  build-and-push:
    name: Build & Push to ECR
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        IMAGE_TAG: latest
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  deploy:
    name: Deploy to EC2
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Copy docker-compose.yml to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "docker-compose.yml"
        target: "/home/ubuntu/"

    - name: SSH into EC2 and Deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        # Note: We don't need to pass all these ENVs, but it doesn't hurt.
        envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION,ECR_REGISTRY,ECR_REPOSITORY,GEMINI_API_KEY
        script: |
          # 1. FIX: Ensure AWS CLI is in the path (Necessary if installed via snap/apt)
          export PATH=$PATH:/snap/bin
          
          # 2. Export Env Vars for Docker Compose & AWS Login
          export AWS_DEFAULT_REGION=${{ secrets.AWS_REGION }}
          export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          export ECR_REGISTRY=${{ secrets.ECR_REGISTRY }}
          
          # 3. Login to ECR (So EC2 can pull the private image)
          aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

          # 4. GENERATE .env FILE (Allows docker-compose.yml to read the keys)
          echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" > .env
          echo "ECR_REGISTRY=${{ secrets.ECR_REGISTRY }}" >> .env
          echo "ECR_REPOSITORY=${{ secrets.ECR_REPOSITORY }}" >> .env

          # 5. Ensure Directory Structure Exists
          mkdir -p oncobot_data/knowledge_base
          mkdir -p oncobot_data/chroma_db

          # 6. Pull Latest Image & Restart Services
          docker compose pull
          docker compose up -d --force-recreate